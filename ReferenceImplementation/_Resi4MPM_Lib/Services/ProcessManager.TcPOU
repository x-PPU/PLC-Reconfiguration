<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="ProcessManager" Id="{c6b7c2c1-716a-413b-ace6-fbd804bbf1e5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ProcessManager IMPLEMENTS IService
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	m_ptrStateTracker: POINTER TO StateTracker;
	m_ptrRaConnector: POINTER TO RaConnector;

	m_ptrPrimitives: ARRAY [ResiConst.ARR_MIN..ResiConst.BEHAVIORS_ARR_MAX] OF POINTER TO ControlPrimitiveBase;
	
	(* Half of the array is reserved for user-defined sequences, the other for runtime-defined compensations. *)
	m_ptrSequences: ARRAY [ResiConst.ARR_MIN..2 * ResiConst.BEHAVIORS_ARR_MAX] OF POINTER TO ModuleSequenceBase;
	
	// compensation sequences that can be defined at runtime
	m_compSeqs: ARRAY [ResiConst.BEHAVIORS_ARR_MAX + 1..ResiConst.BEHAVIORS_ARR_MAX + ResiConst.COMPENSATIONS_ARR_MAX] OF LinearSequence;
	m_compSeqsIdx: UINT := ResiConst.BEHAVIORS_ARR_MAX + 1;
	m_activeCompensationState: ECompSeqState;
	m_activeCompensationIdx: UINT;
	
	// POUs capable of observing part of the process state
	m_hwObsIdx: UINT := 0;
	m_hwObservations: ARRAY [ResiConst.ARR_MIN..ResiConst.OBSERVERS_ARR_MAX] OF POINTER TO HardwareObservationBase;
	
	(* COMPENSATION
	   Array index: ID of the sick Control Primitive.
	   Array entry: specification of the primitive/sequence that should be executed instead. *)
	m_retargets: ARRAY [ResiConst.ARR_MIN..ResiConst.BEHAVIORS_ARR_MAX] OF SRetargeting;
	
	(* RECOVERY *)
	m_recoverySequence: LinearSequence;
	
	m_finishedAutonomously: ARRAY [ResiConst.ARR_MIN..ResiConst.BEHAVIORS_ARR_MAX] OF BOOL;
	m_finishedAutoBuffer: ARRAY [ResiConst.ARR_MIN..ResiConst.BEHAVIORS_ARR_MAX] OF BOOL;
	
	// ABORT
	m_abortState: EAbortState;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Property Name="AbortActive" Id="{df93be51-dd9d-48ac-a0ad-a7c3ec7f0770}">
      <Declaration><![CDATA[PROPERTY AbortActive : BOOL]]></Declaration>
      <Get Name="Get" Id="{b857f91f-67dd-4866-ae73-e3e482dd0493}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[AbortActive := m_abortState = EAbortState.requested OR m_abortState = EAbortState.aborting;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="AddObservation" Id="{99bd3700-5d88-4280-a7c2-0d6acea77ce6}">
      <Declaration><![CDATA[METHOD AddObservation : BOOL
VAR_INPUT
	i_ptrObservation: POINTER TO HardwareObservationBase;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_hwObservations[m_hwObsIdx] := i_ptrObservation;
m_hwObsIdx := m_hwObsIdx + 1;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddPrimitive" Id="{cbb492b3-6b18-4f15-ba6f-79bb0362e7d4}">
      <Declaration><![CDATA[METHOD AddPrimitive : BOOL
VAR_INPUT
	i_ptrPrimitive: POINTER TO ControlPrimitiveBase;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF m_ptrPrimitives[i_ptrPrimitive^.Id] <> 0 THEN
	// already initialized a primitive with that ID
	AddPrimitive := FALSE;
	RETURN;
END_IF

m_ptrPrimitives[i_ptrPrimitive^.Id] := i_ptrPrimitive;
AddPrimitive := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddSequence" Id="{b12b9345-d2ed-405d-bf4e-bf9cd7d819b3}">
      <Declaration><![CDATA[METHOD AddSequence : BOOL
VAR_INPUT
	i_ptrSequence: POINTER TO ModuleSequenceBase;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF m_ptrSequences[i_ptrSequence^.Id] <> 0 THEN
	// already initialized a sequence with that ID
	AddSequence := FALSE;
	RETURN;
END_IF

m_ptrSequences[i_ptrSequence^.Id] := i_ptrSequence;
AddSequence := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Compensate" Id="{2f261bf9-4e7e-40f4-bfce-6d54158f55ea}">
      <Declaration><![CDATA[(* Applies a new compensation, i.e., the replacement of a "sick" primitive with another primitive or  a module sequence. *)
METHOD Compensate : BOOL
VAR_INPUT
	i_ptrCompensation: POINTER TO SCompensation;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF i_ptrCompensation^.NewType = EBehaviorType.none THEN
	Compensate := FALSE;
	RETURN;
END_IF

CASE i_ptrCompensation^.NewType OF
	EBehaviorType.control_primitive:
		// check if the specified replacement exists
		IF m_ptrPrimitives[i_ptrCompensation^.NewId] = 0 THEN
			Compensate := FALSE;
			RETURN;
		END_IF
		
		m_retargets[i_ptrCompensation^.SickPrimitiveId].RetargetType := ERetargetType.primitive_target;
		m_retargets[i_ptrCompensation^.SickPrimitiveId].TargetId := i_ptrCompensation^.NewId;
		m_retargets[i_ptrCompensation^.SickPrimitiveId].OverwriteParams := i_ptrCompensation^.ParameterSets[0];

	EBehaviorType.user_sequence:
		// check if the specified replacement exists
		IF m_ptrSequences[i_ptrCompensation^.NewId] = 0 THEN
			Compensate := FALSE;
			RETURN;
		END_IF
		
		m_retargets[i_ptrCompensation^.SickPrimitiveId].RetargetType := ERetargetType.sequence_target;
		m_retargets[i_ptrCompensation^.SickPrimitiveId].TargetId := i_ptrCompensation^.NewId;
		m_retargets[i_ptrCompensation^.SickPrimitiveId].OverwriteParams := i_ptrCompensation^.ParameterSets[0];

	EBehaviorType.generated_sequence:
		m_compSeqs[m_compSeqsIdx].ProvideServices(THIS, THIS^.m_ptrStateTracker, THIS^.m_ptrRaConnector);
		m_compSeqs[m_compSeqsIdx].i_primitiveParams := i_ptrCompensation^.ParameterSets;
		m_compSeqs[m_compSeqsIdx].i_primitiveIds := i_ptrCompensation^.PrimitiveIds;
		
		m_ptrSequences[m_compSeqsIdx] := ADR(m_compSeqs[m_compSeqsIdx]);
		m_retargets[i_ptrCompensation^.SickPrimitiveId].RetargetType := ERetargetType.sequence_target;
		m_retargets[i_ptrCompensation^.SickPrimitiveId].TargetId := m_compSeqsIdx;
		
		m_compSeqsIdx := m_compSeqsIdx + 1;
END_CASE

Compensate := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="CompSeqActive" Id="{de638302-c511-40bc-9e65-32ff10a76666}">
      <Declaration><![CDATA[// When a compensation *sequence* is active, other primitive calls must be suspended to avoid interference.
PROPERTY CompSeqActive : BOOL]]></Declaration>
      <Get Name="Get" Id="{3cb343a2-850f-4752-80fc-5bcc859450c0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[CompSeqActive := m_activeCompensationState = ECompSeqState.preparing OR m_activeCompensationState = ECompSeqState.running;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="CyclicManageBehavior" Id="{3e59a9af-b171-4f9c-82bd-9f67a9b5552a}">
      <Declaration><![CDATA[METHOD CyclicManageBehavior : BOOL
VAR
	i: UINT;
	p_id: UINT;
	m_sequenceStatus: EOperationResult;
	m_allAborted: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ABORT
CASE m_abortState OF
	EAbortState.none:
		;
		
	EAbortState.requested:
		m_abortState := EAbortState.aborting;
		
	EAbortState.aborting:
		m_allAborted := TRUE;
		FOR i := ResiConst.ARR_MIN TO ResiConst.BEHAVIORS_ARR_MAX DO
			IF m_ptrPrimitives[i] <> 0 THEN
				IF NOT m_ptrPrimitives[i]^.Abort() THEN
					m_allAborted := FALSE;
				END_IF
			END_IF	
		END_FOR
		
		IF m_allAborted THEN
			m_abortState := EAbortState.aborted;
		END_IF
		
	EAbortState.aborted:
		m_abortState := EAbortState.none;
END_CASE


// COMPENSATION: while a compensation sequence is active, other primitives must be suspended to avoid interference (handled at MAIN level)
CASE m_activeCompensationState OF
	ECompSeqState.preparing:
		// finish all running primitives
		IF FinishPrimitives(i_abortRecoveries := TRUE) THEN
			m_activeCompensationState := ECompSeqState.running;
			
			// Reset the "finished autonomously" flag for all primitives involved in this compensation. Otherwise, the Execute 
			// method will return TRUE without doing anything.
			m_finishedAutoBuffer := m_finishedAutonomously;
			FOR i := ResiConst.ARR_MIN TO ResiConst.MODULE_SEQ_ARR_MAX DO
				p_id := m_compSeqs[m_activeCompensationIdx].i_primitiveIds[i];
				m_finishedAutonomously[p_id] := FALSE;
			END_FOR
		END_IF
	
	ECompSeqState.running:
		m_ptrSequences[m_activeCompensationIdx]^(o_status => m_sequenceStatus);
		IF m_sequenceStatus = EOperationResult.success THEN
			m_activeCompensationState := ECompSeqState.finished;
		END_IF
		
	ECompSeqState.finished:
		// restore the "finished autonomously" flags again
		m_finishedAutonomously := m_finishedAutoBuffer;	
		m_activeCompensationState := ECompSeqState.none;
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Execute" Id="{2deec2cc-272f-4875-8f29-d52e0f2f404c}">
      <Declaration><![CDATA[(* Executes the requested Control Primitive or Module Sequence. 
COMPENSATION: If a compensation was previously registered, the replacement is executed instead. *)
METHOD Execute : EOperationResult
VAR_INPUT
	i_type: EBehaviorType;
	i_id: UINT;
	i_params: ParameterSet;
END_VAR
VAR
	i: UINT;
	m_actualId: UINT;
	m_result: INT;
	m_overwrites: ARRAY [ResiConst.ARR_MIN..ResiConst.PARAMS_ARR_MAX] OF SNamedValue;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// copyset/overwrite additional parameters specified by the retargeting
IF m_retargets[i_id].RetargetType <> ERetargetType.not_retargeted THEN
	i_params := i_params;
	m_overwrites := m_retargets[i_id].OverwriteParams.Parameters;
	FOR i := ResiConst.ARR_MIN TO ResiConst.PARAMS_ARR_MAX DO
		IF m_overwrites[i].DataType = EDataType.binary THEN
			i_params.SetParam_Binary(m_overwrites[i].Name, m_overwrites[i].Value.Binary);
		ELSIF m_overwrites[i].DataType = EDataType.numeric THEN
			i_params.SetParam_Numeric(m_overwrites[i].Name, m_overwrites[i].Value.Numeric);
		ELSIF m_overwrites[i].DataType = EDataType.string_t THEN
			i_params.SetParam_String(m_overwrites[i].Name, m_overwrites[i].Value.String_t);
		END_IF
	END_FOR	
END_IF

IF i_type = EBehaviorType.control_primitive THEN
	// if the primitive was finished in the background before recovery (FinishPrimitives), return the success signal
	IF m_finishedAutonomously[i_id] THEN
		Execute := EOperationResult.success;
		m_finishedAutonomously[i_id] := FALSE;
		RETURN;
	END_IF	

	CASE m_retargets[i_id].RetargetType OF
		// execute the requested Control Primitive
		ERetargetType.not_retargeted:
			IF m_ptrPrimitives[i_id] = 0 THEN
				Execute := EOperationResult.failed;
				RETURN;
			END_IF
			 
			m_ptrPrimitives[i_id]^(
				i_params := i_params,
				o_status => Execute);
			
		// primitive compensated by other primitive
		ERetargetType.primitive_target:
			IF m_ptrPrimitives[m_retargets[i_id].TargetId] = 0 THEN
				Execute := EOperationResult.failed;
				RETURN;
			END_IF
			
			m_ptrPrimitives[m_retargets[i_id].TargetId]^(
				i_params := i_params,
				o_status => Execute);
			
		// primitive compensated by sequence (i_primitiveParams were already parsed in ProcessManager.Compensate())
		ERetargetType.sequence_target:
			IF m_ptrSequences[m_retargets[i_id].TargetId] = 0 THEN
				Execute := EOperationResult.failed;
				RETURN;
			END_IF
			
			// the rest is handled in CyclicManageBehavior
			m_activeCompensationState := ECompSeqState.preparing;
			m_activeCompensationIdx := m_retargets[i_id].TargetId;
			Execute := EOperationResult.success;
	END_CASE

ELSIF i_type = EBehaviorType.user_sequence THEN
	// execute the requested Module Sequence
	IF m_ptrSequences[i_id] = 0 THEN
		Execute := EOperationResult.failed;
		RETURN;
	END_IF
	
	m_ptrSequences[i_id]^(
		i_params := i_params,
		o_status => Execute);
		
ELSE 
	// generated_sequence cannot be called directly
	Execute := EOperationResult.failed;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecuteRecovery" Id="{456cd01c-35b5-44f3-9d9c-8f43686ad937}">
      <Declaration><![CDATA[(* Called over multiple cycles until all recovery primitives finished. *)
METHOD ExecuteRecovery : EOperationResult
VAR_INPUT
	i_strategy: SRecovery;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_recoverySequence(
	i_params := i_strategy.RecoveryParameters,
	i_primitiveIds := i_strategy.RecoveryStrategy,
	o_status => ExecuteRecovery);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="FinishPrimitives" Id="{1d03d996-9033-4613-9627-673c9799e427}">
      <Declaration><![CDATA[METHOD FinishPrimitives : BOOL
VAR_INPUT
	i_abortRecoveries: BOOL;
END_VAR
VAR
	i: UINT;
	m_allFinished: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_allFinished := TRUE;
FOR i := ResiConst.ARR_MIN TO ResiConst.BEHAVIORS_ARR_MAX DO
	IF m_ptrPrimitives[i] <> 0 THEN
		IF m_ptrPrimitives[i]^.o_status = EOperationResult.busy 
			OR m_ptrPrimitives[i]^.o_status = EOperationResult.waiting 
			OR (i_abortRecoveries AND m_ptrPrimitives[i]^.o_status = EOperationResult.recovering) THEN
			
			m_ptrPrimitives[i]^();
			m_allFinished := FALSE;
			
			IF m_ptrPrimitives[i]^.o_status = EOperationResult.success THEN
				// after finishing, the success must be communicated to the application code once the automatic operation resumes (after recovery)
				m_finishedAutonomously[i] := TRUE;
			END_IF
		END_IF
	END_IF	
END_FOR

FinishPrimitives := m_allFinished;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetBehaviorPtr" Id="{61d61c92-26e6-4d55-be65-17f7c00ad56b}">
      <Declaration><![CDATA[METHOD GetBehaviorPtr : POINTER TO BehaviorBase
VAR_INPUT
	i_type: EBehaviorType;
	i_id: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF i_type = EBehaviorType.control_primitive THEN
	GetBehaviorPtr := m_ptrPrimitives[i_id];
ELSIF i_type = EBehaviorType.user_sequence OR i_type = EBehaviorType.generated_sequence THEN
	GetBehaviorPtr := m_ptrSequences[i_id];
ELSE
	GetBehaviorPtr := 0;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ProvideServices" Id="{0597880f-7a29-4802-aa3a-a3dc4fbb2f27}">
      <Declaration><![CDATA[METHOD ProvideServices : BOOL
VAR_INPUT
	i_ptrStateTracker: POINTER TO StateTracker;
	i_ptrRaConnector: POINTER TO RaConnector;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.m_ptrStateTracker := i_ptrStateTracker;
THIS^.m_ptrRaConnector := i_ptrRaConnector;

THIS^.m_recoverySequence.ProvideServices(THIS, i_ptrStateTracker, i_ptrRaConnector);]]></ST>
      </Implementation>
    </Method>
    <Method Name="RequestAbort" Id="{33ced1d6-f574-461c-bd7f-3d17244bb2f0}">
      <Declaration><![CDATA[METHOD RequestAbort : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF m_abortState = EAbortState.none THEN
	m_abortState := EAbortState.requested;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetDefinitions" Id="{2344c952-d2c4-452d-95ab-b66a05e84ad8}">
      <Declaration><![CDATA[METHOD ResetDefinitions : BOOL
VAR_INPUT
END_VAR
VAR 
	i: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := ResiConst.ARR_MIN TO ResiConst.OBSERVERS_ARR_MAX DO
	IF m_hwObservations[i] <> 0 THEN
		m_hwObservations[i]^.ResetDefinition();
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetPrimitiveCondition" Id="{9925dccf-10b9-4827-978b-1fdbe812ec93}">
      <Declaration><![CDATA[METHOD SetPrimitiveCondition : BOOL
VAR_INPUT
	i_primitiveId: UINT;
	i_isPre: BOOL;
	i_condition: IExpression;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF i_isPre THEN
	THIS^.m_ptrPrimitives[i_primitiveId]^.Precondition := i_condition;
ELSE
	THIS^.m_ptrPrimitives[i_primitiveId]^.Postcondition := i_condition;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateProcessObservation" Id="{de003900-03a3-4347-b6e5-29da881184b0}">
      <Declaration><![CDATA[(* Update a ProcessState instance with the current values. *)
METHOD UpdateProcessObservation : BOOL
VAR_IN_OUT
	io_processState: ProcessState;
END_VAR
VAR 
	i: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := ResiConst.ARR_MIN TO ResiConst.OBSERVERS_ARR_MAX DO
	IF m_hwObservations[i] <> 0 THEN
		m_hwObservations[i]^.UpdateProcessObservation(io_processState);
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="ProcessManager">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.AbortActive.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.AddObservation">
      <LineId Id="74" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.AddPrimitive">
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="20" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.AddSequence">
      <LineId Id="15" Count="6" />
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.Compensate">
      <LineId Id="133" Count="14" />
      <LineId Id="183" Count="0" />
      <LineId Id="148" Count="9" />
      <LineId Id="184" Count="0" />
      <LineId Id="158" Count="13" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.CompSeqActive.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.CyclicManageBehavior">
      <LineId Id="99" Count="0" />
      <LineId Id="138" Count="1" />
      <LineId Id="141" Count="5" />
      <LineId Id="148" Count="10" />
      <LineId Id="147" Count="0" />
      <LineId Id="159" Count="2" />
      <LineId Id="140" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="38" Count="5" />
      <LineId Id="77" Count="2" />
      <LineId Id="92" Count="0" />
      <LineId Id="80" Count="2" />
      <LineId Id="76" Count="0" />
      <LineId Id="44" Count="6" />
      <LineId Id="52" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="88" Count="1" />
      <LineId Id="55" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.Execute">
      <LineId Id="460" Count="0" />
      <LineId Id="380" Count="0" />
      <LineId Id="461" Count="0" />
      <LineId Id="466" Count="0" />
      <LineId Id="444" Count="0" />
      <LineId Id="462" Count="0" />
      <LineId Id="455" Count="4" />
      <LineId Id="451" Count="0" />
      <LineId Id="446" Count="0" />
      <LineId Id="391" Count="2" />
      <LineId Id="481" Count="0" />
      <LineId Id="483" Count="0" />
      <LineId Id="485" Count="2" />
      <LineId Id="484" Count="0" />
      <LineId Id="482" Count="0" />
      <LineId Id="394" Count="28" />
      <LineId Id="510" Count="0" />
      <LineId Id="514" Count="0" />
      <LineId Id="516" Count="0" />
      <LineId Id="518" Count="0" />
      <LineId Id="517" Count="0" />
      <LineId Id="427" Count="16" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.ExecuteRecovery">
      <LineId Id="52" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="38" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.FinishPrimitives">
      <LineId Id="48" Count="3" />
      <LineId Id="72" Count="1" />
      <LineId Id="52" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="53" Count="10" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.GetBehaviorPtr">
      <LineId Id="6" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="11" Count="3" />
      <LineId Id="10" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.ProvideServices">
      <LineId Id="9" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.RequestAbort">
      <LineId Id="6" Count="0" />
      <LineId Id="10" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.ResetDefinitions">
      <LineId Id="8" Count="3" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.SetPrimitiveCondition">
      <LineId Id="21" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ProcessManager.UpdateProcessObservation">
      <LineId Id="7" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="12" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>