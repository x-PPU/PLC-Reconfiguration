<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="ObserveLSC" Id="{7cb58183-4d7f-46ea-947b-b391dd8eb06d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ObserveLSC EXTENDS HardwareObservationBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	m_ptrLSC: POINTER TO LargeSortingConveyor;
	m_ptrLSCWP: POINTER TO xPPUProduct;
	
	m_rtAtStart: R_TRIG;
	m_rtLightAtStart: R_TRIG;
	m_rtLightAtMid: R_TRIG;
	m_rtLightAtEnd: R_TRIG;
	m_rtMetalAtStart: R_TRIG;
	m_rtMetalAtMid: R_TRIG;
	m_rtWpAtRampStart: R_TRIG;
	m_rtWpAtRampMiddle: R_TRIG;
	m_rtWpAtRampEnd: R_TRIG;
	
	m_LSCemptytimeout: TON;
	m_resetProductDefined: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="FB_init" Id="{074070f9-087a-4a43-9bd9-f473b0ca7edf}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)

	i_ptrLSC: POINTER TO LargeSortingConveyor;
	i_ptrWP: POINTER TO IProduct;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_ptrLSC := i_ptrLSC;
IF NOT __QUERYPOINTER(i_ptrWP^, m_ptrLSCWP) THEN
	FB_init := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetDefinition" Id="{7434da2f-f89a-4c47-8629-1c0de7ef8d95}">
      <Declaration><![CDATA[METHOD  ResetDefinition : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_resetProductDefined := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateProcessObservation" Id="{b0d07867-4543-453e-a76a-e6e0e423957a}">
      <Declaration><![CDATA[(* Update an instance of ProcessState with the part of the process that can be observed by this Hardware Interface. *)
METHOD UpdateProcessObservation : BOOL
VAR_IN_OUT
	io_processState: ProcessState;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_rtAtStart(CLK := m_ptrLSC^.WPAtStart);
m_rtLightAtStart(CLK := m_ptrLSC^.LightWPAtStart);
m_rtLightAtMid(CLK := m_ptrLSC^.LightWPAtMid);
m_rtLightAtEnd(CLK := m_ptrLSC^.LightWPAtEnd);
m_rtMetalAtStart(CLK := m_ptrLSC^.MetalWPAtStart);
m_rtMetalAtMid(CLK := m_ptrLSC^.MetalWPAtMid);
m_rtWpAtRampStart(CLK := m_ptrLSC^.WPAtRampStart);
m_rtWpAtRampMiddle(CLK := m_ptrLSC^.WPAtRampMiddle);
m_rtWpAtRampEnd(CLK := m_ptrLSC^.WPAtRampEnd);

io_processState.UpdateState_Binary(EProcessVariables.LSC_WorkpieceAtEntry, m_ptrLSC^.WPAtStart, TRUE);
io_processState.UpdateState_Binary(EProcessVariables.LSC_WPAtRampStart, m_ptrLSC^.WPAtRampStart, TRUE);
io_processState.UpdateState_Binary(EProcessVariables.LSC_WPAtRampMiddle, m_ptrLSC^.WPAtRampMiddle, TRUE);
io_processState.UpdateState_Binary(EProcessVariables.LSC_WPAtRampEnd, m_ptrLSC^.WPAtRampEnd, TRUE);
io_processState.UpdateState_Binary(EProcessVariables.LSC_SwitchExtended, m_ptrLSC^.m_Switch.Extended, TRUE);
io_processState.UpdateState_Binary(EProcessVariables.LSC_SwitchRetracted, m_ptrLSC^.m_Switch.Retracted, TRUE);
io_processState.UpdateState_Binary(EProcessVariables.LSC_WPAtInductiveSensorEnd, m_ptrLSC^.MetalWPAtMid, TRUE);

IF m_rtWpAtRampStart.Q THEN
	io_processState.UpdateState_NumericIncrement(EProcessVariables.LSC_RampStartWPCount, TRUE);
END_IF
IF m_rtWpAtRampMiddle.Q THEN
	io_processState.UpdateState_NumericIncrement(EProcessVariables.LSC_RampMiddleWPCount, TRUE);
END_IF
IF m_rtWpAtRampEnd.Q THEN
	io_processState.UpdateState_NumericIncrement(EProcessVariables.LSC_RampEndWPCount, TRUE);
END_IF

io_processState.UpdateState_Defined(EProcessVariables.LSC_WorkpieceAtEntry, TRUE);
io_processState.UpdateState_Defined(EProcessVariables.LSC_WPAtRampStart, TRUE);
io_processState.UpdateState_Defined(EProcessVariables.LSC_WPAtRampMiddle, TRUE);
io_processState.UpdateState_Defined(EProcessVariables.LSC_WPAtRampEnd, TRUE);
io_processState.UpdateState_Defined(EProcessVariables.LSC_SwitchExtended, TRUE);
io_processState.UpdateState_Defined(EProcessVariables.LSC_SwitchRetracted, TRUE);
io_processState.UpdateState_Defined(EProcessVariables.LSC_WPAtInductiveSensorEnd, TRUE);
// TODO - the following are technically not defined but how can we avoid that?
io_processState.UpdateState_Defined(EProcessVariables.LSC_RampStartWPCount, TRUE);
io_processState.UpdateState_Defined(EProcessVariables.LSC_RampMiddleWPCount, TRUE);
io_processState.UpdateState_Defined(EProcessVariables.LSC_RampEndWPCount, TRUE);

// update WP info (if there are sensors available), then update the process variables list
IF m_rtAtStart.Q THEN
	m_ptrLSCWP^.IsPresent := TRUE;
	io_processState.UpdateState_Defined(EProcessVariables.LSC_ProductType, TRUE);
END_IF
IF m_rtLightAtStart.Q OR m_rtLightAtMid.Q OR m_rtLightAtEnd.Q THEN
	m_ptrLSCWP^.IsLight := TRUE;
END_IF
IF m_rtMetalAtStart.Q OR m_rtMetalAtMid.Q THEN
	m_ptrLSCWP^.IsMetal := TRUE;
END_IF

// reset IsPresent if any of the ramps are triggered
IF m_ptrLSC^.WPAtRampStart OR m_ptrLSC^.WPAtRampMiddle OR m_ptrLSC^.WPAtRampEnd THEN
	m_ptrLSCWP^.IsPresent := FALSE;
END_IF

io_processState.UpdateState_Numeric(EProcessVariables.LSC_ProductType, UINT_TO_LREAL(m_ptrLSCWP^.Material), TRUE);

//if the conveyor moves forward for a certain time, it has to empty, therefore LSCProductType is defined
IF m_ptrLSC^.Motor.TurningClockwise THEN
	m_LSCemptytimeout(IN:= TRUE, PT:=T#3500MS);
ELSE
	m_LSCemptytimeout(IN:= FALSE);
END_IF

IF m_LSCemptytimeout.Q THEN
	io_processState.UpdateState_Defined(EProcessVariables.LSC_ProductType, TRUE);
	m_LSCemptytimeout(IN:= FALSE);
END_IF

IF m_resetProductDefined THEN
	m_resetProductDefined := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="ObserveLSC">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="ObserveLSC.FB_init">
      <LineId Id="28" Count="3" />
      <LineId Id="27" Count="0" />
    </LineIds>
    <LineIds Name="ObserveLSC.ResetDefinition">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="ObserveLSC.UpdateProcessObservation">
      <LineId Id="319" Count="4" />
      <LineId Id="195" Count="0" />
      <LineId Id="330" Count="2" />
      <LineId Id="325" Count="0" />
      <LineId Id="324" Count="0" />
      <LineId Id="196" Count="3" />
      <LineId Id="202" Count="1" />
      <LineId Id="327" Count="0" />
      <LineId Id="326" Count="0" />
      <LineId Id="333" Count="1" />
      <LineId Id="337" Count="0" />
      <LineId Id="344" Count="0" />
      <LineId Id="339" Count="0" />
      <LineId Id="341" Count="0" />
      <LineId Id="345" Count="0" />
      <LineId Id="343" Count="0" />
      <LineId Id="207" Count="5" />
      <LineId Id="215" Count="1" />
      <LineId Id="313" Count="1" />
      <LineId Id="316" Count="1" />
      <LineId Id="217" Count="0" />
      <LineId Id="224" Count="2" />
      <LineId Id="290" Count="0" />
      <LineId Id="227" Count="5" />
      <LineId Id="301" Count="0" />
      <LineId Id="305" Count="0" />
      <LineId Id="300" Count="0" />
      <LineId Id="302" Count="2" />
      <LineId Id="306" Count="1" />
      <LineId Id="280" Count="0" />
      <LineId Id="267" Count="1" />
      <LineId Id="264" Count="0" />
      <LineId Id="270" Count="1" />
      <LineId Id="269" Count="0" />
      <LineId Id="275" Count="0" />
      <LineId Id="266" Count="0" />
      <LineId Id="291" Count="0" />
      <LineId Id="278" Count="0" />
      <LineId Id="273" Count="0" />
      <LineId Id="292" Count="3" />
      <LineId Id="81" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>